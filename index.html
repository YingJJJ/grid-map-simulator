<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式网格地图</title>
    <!-- 添加Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
            margin-top: 20px;
        }
        
        /* 帮助文档抽屉样式 */
        .help-drawer {
            width: 0;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            background-color: #f8f9fa;
            overflow-x: hidden;
            transition: 0.3s;
            height: 100%;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            padding-top: 20px;
        }
        
        .help-drawer.open {
            width: 350px;
        }
        
        .help-content {
            padding: 20px;
            margin: 10px;
            overflow-y: auto;
            height: calc(100% - 60px);
        }
        
        .help-close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
            color: #333;
        }
        
        .help-open-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 999;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        }
        
        /* 新增的连线模式开关样式 */
        .mode-switch {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .mode-switch label {
            margin-right: 10px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .mode-switch input {
            margin-right: 5px;
        }
        
        /* 连线样式 - 鼠标悬停时高亮 */
        .line-hover {
            stroke: #e74c3c !important;
            stroke-width: 3px !important;
            cursor: pointer;
        }
        
        /* 手动模式下的起点样式 - 紫色 */
        .dot.manual-start {
            background-color: #9b59b6; /* 紫色 */
            box-shadow: 0 0 8px #9b59b6; /* 添加与红色点相同的阴影效果 */
        }
        
        /* 原有的样式保持不变 */
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 0 20px;
        }
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 8px 15px;
            background-color: #3498db;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .grid-container {
            position: relative;
            display: grid;
            grid-template-columns: repeat(10, 50px);
            grid-template-rows: repeat(10, 50px);
            gap: 2px;
            background-color: #ccc;
            padding: 2px;
            border-radius: 4px;
        }
        
        .grid-cell {
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        
        .dot {
            width: 10px;
            height: 10px;
            background-color: #3498db;
            border-radius: 50%;
            transition: all 0.3s;
            position: relative;
            z-index: 2;
        }
        
        .dot.hidden {
            opacity: 0;
        }
        
        .dot.selected {
            background-color: #e74c3c;
            box-shadow: 0 0 8px #e74c3c;
            transform: scale(1.5);
        }
        
        .grid-cell.empty {
            justify-content: center;
            align-items: center;
        }
        
        #linesCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        
        .stats {
            margin-top: 10px;
            font-size: 14px;
            color: #34495e;
            background-color: #f8f9fa;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .timer-container {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .timer-input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .timer-display {
            font-size: 16px;
            font-weight: bold;
            color: #e74c3c;
            min-width: 80px;
            text-align: center;
        }
        
        .saved-layouts {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        .save-section, .load-section {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        #layoutName {
            padding: 8px;
            margin-right: 5px;
            width: 200px;
        }
        
        #savedLayouts {
            padding: 8px;
            margin-right: 5px;
            width: 200px;
        }
    </style>
</head>
<body>
    <!-- 帮助文档抽屉 -->
    <div id="helpDrawer" class="help-drawer">
        <span id="closeHelpBtn" class="help-close-btn">&times;</span>
        <div class="help-content">
            <h2>网格地图使用指南</h2>
            <hr>
            
            <h4>1. 基本功能介绍</h4>
            <p>本工具提供了一个10×10的交互式网格地图，您可以在网格上显示/隐藏点，并按特定规则连接它们。</p>
            <p><span style="color: red; font-weight: bold;">另：</span><br>1.点代表角色<br>2.线代表传染路径<br>3.红色点代表被传染debuff的角色，没有被传染的角色则为绿色<br>4.倒计时结束后未被传染的角色将被隐藏（死亡）。</p>
            
            <h4>2. 点（角色）的操作</h4>
            <ul>
                <li><b>显示/隐藏点</b>：点击网格中的格子可以显示或隐藏该位置的点</li>
                <li><b>最大点数限制</b>：系统限制最多同时显示25个点</li>
                <li><b>随机选择点</b>：点击"随机选择点"按钮可以随机在网格中显示25个点</li>
            </ul>
            
            <h4>3. 连线规则</h4>
            <ul>
                <li><b>连线条件</b>：只有两点之间的距离为√5时才能连线</li>
                <li><b>连线方法</b>：先点击红色点，然后点击可以连线的点</li>
                <li><b>距离计算</b>：如果两点坐标为(x1,y1)和(x2,y2)，则当(x1-x2)²+(y1-y2)²=5时可以连线</li>
                <li><b>具体情况</b>：当两点横向距离为2、纵向距离为1，或横向距离为1、纵向距离为2时可以连线</li>
            </ul>
            
            <h4>4. 计时器功能</h4>
            <ul>
                <li><b>设置时间</b>：在计时器输入框中设置倒计时秒数</li>
                <li><b>开始计时</b>：当选择红色点后计时器自动开始</li>
                <li><b>重置计时</b>：使用"重置计时器"按钮重置计时</li>
                <li><b>时间到</b>：计时结束后会自动隐藏所有未连接的点</li>
            </ul>
            
            <h4>5. 布局管理</h4>
            <ul>
                <li><b>保存布局</b>：将当前可见点的布局保存到本地存储</li>
                <li><b>加载布局</b>：从本地存储加载之前保存的点布局</li>
                <li><b>删除布局</b>：从本地存储中删除选定的布局</li>
            </ul>
            
            <h4>6. 提示与技巧</h4>
            <ul>
                <li>红色点表示已选择或已连线的点</li>
                <li>连线后的点会保持红色，便于继续连接新的点</li>
                <li>可以使用计时器来增加挑战难度</li>
                <li>对于常用的布局，建议保存以便下次快速加载</li>
            </ul>
        </div>
    </div>
    
    <!-- 打开帮助按钮 -->
    <button id="openHelpBtn" class="help-open-btn">帮助文档</button>

    <!-- 添加欢迎弹窗 -->
    <div class="modal fade" id="welcomeModal" tabindex="-1" aria-labelledby="welcomeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="welcomeModalLabel">欢迎使用交互式网格地图</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>1. 点代表角色</p>
                    <p>2. 线代表传染路径</p>
                    <p>3. 红色点代表被传染debuff的角色，没有被传染的角色则为绿色</p>
                    <p>4. 倒计时结束后未被传染的角色将被隐藏（死亡）</p>
                    <p>5. 请使用“随机选择点”点名一名角色，开始游戏</p>
                    <p>6. <span style="color: red; font-weight: bold;">重要提示：</span>传染路径会自动计算满足传染条件的点，无需手动判断是否满足传染条件！这是为了节省操作时间</p>
                    <p><strong>更多功能请点击左上角帮助文档查看</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">确认</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 添加更新记录模态框 -->
    <div class="modal fade" id="updateLogModal" tabindex="-1" aria-labelledby="updateLogModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="updateLogModalLabel">功能更新记录</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="update-log">
                        <h4>2025年3月16日更新</h4>
                        <h5>新增功能：</h5>
                        <ol>
                            <li><strong>手动/自动连接模式切换</strong>：
                                <ul>
                                    <li>添加了模式切换开关，可以选择手动或自动连接模式</li>
                                    <li>手动模式：可以手动选择起点（紫色标记），然后连接其他点</li>
                                    <li>自动模式：系统自动查找符合条件的红色点进行连接</li>
                                </ul>
                            </li>
                            <li><strong>计时器优化</strong>：
                                <ul>
                                    <li>移除了计时器的最大时间限制，现在可以设置任意长的时间</li>
                                    <li>切换连接模式时不再重置计时器</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <h5>优化与修复：</h5>
                        <ol>
                            <li>将所有"根号5"表述替换为标准数学符号"√5"</li>
                            <li>手动模式下起点使用紫色标记，更容易区分</li>
                            <li>优化模式切换逻辑，保持连接点状态一致</li>
                        </ol>
                        
                        <h4>之前的更新</h4>
                        <h5>帮助文档功能：</h5>
                        <ol>
                            <li>添加了左侧抽屉式帮助文档，提供详细的使用说明</li>
                            <li>包含基本功能介绍、点的操作、连线规则、计时器功能等内容</li>
                            <li>添加了重要提示，说明传染路径会自动计算满足传染条件的点</li>
                        </ol>
                        
                        <h5>欢迎弹窗功能：</h5>
                        <ol>
                            <li>首次访问时显示欢迎弹窗，提供简要的使用指南</li>
                            <li>调整确认按钮文本为"确认"</li>
                        </ol>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                </div>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="controls">
            <button id="showAll">显示所有点</button>
            <button id="hideAll">隐藏所有点</button>
            <button id="toggleAll">切换所有点</button>
            <button id="randomDots">随机显示点</button>
            <button id="clearLines">清除所有连线</button>
            <button id="randomSelect">随机选择点</button>
            <button id="resetTimer">重置计时器</button>
            <button id="updateLogBtn" style="background-color: #9b59b6; color: white;">更新记录</button>
            <!-- 用于测试弹窗的按钮 -->
            <!-- <button id="testModalBtn" style="background-color: #ff9800;">测试弹窗</button> -->
        </div>
        
        <!-- 添加连线模式选择开关 -->
        <div class="mode-switch">
            <label>
                <input type="radio" name="connectionMode" value="auto" checked> 自动连接模式
            </label>
            <label>
                <input type="radio" name="connectionMode" value="manual"> 手动选择模式
            </label>
        </div>
        
        <div class="saved-layouts">
            <div class="save-section">
                <input type="text" id="layoutName" placeholder="点位布局名称">
                <button id="saveLayout">保存当前点位</button>
            </div>
            <div class="load-section">
                <select id="savedLayouts">
                    <option value="">-- 选择已保存的点位 --</option>
                </select>
                <button id="loadLayout">加载点位</button>
                <button id="deleteLayout">删除点位</button>
            </div>
        </div>
        <div class="grid-container" id="grid">
            <canvas id="linesCanvas"></canvas>
        </div>
        <div class="status" id="status">点击“随机选择点”按钮开始游戏</div>
        <div class="stats" id="pointStats">可见点: 0/100</div>
        <div class="timer-container">
            <label for="timerInput">计时器(秒):</label>
            <input type="number" id="timerInput" class="timer-input" min="1" value="30">
            <div class="timer-display" id="timerDisplay">00:00</div>
        </div>
    </div>

    <!-- 添加Bootstrap JS和Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // DOMContentLoaded事件处理
        document.addEventListener('DOMContentLoaded', function() {
            // 所有DOM元素加载完成后执行初始化
            
            // 初始化帮助抽屉
            initHelpDrawer();
            
            // 初始化欢迎弹窗
            initWelcomeModal();
            
            // 初始化网格功能
            initializeGrid();
            
            // 添加更新记录按钮事件监听
            document.getElementById('updateLogBtn').addEventListener('click', function() {
                const updateLogModal = new bootstrap.Modal(document.getElementById('updateLogModal'));
                updateLogModal.show();
            });
        });
        
        // 初始化欢迎弹窗
        function initWelcomeModal() {
            // 检查是否是首次访问
            const hasVisited = localStorage.getItem('hasVisitedGridApp');
            
            // 清除标记以便测试（开发期间可以使用，发布时请注释掉）
            // localStorage.removeItem('hasVisitedGridApp');
            
            if (!hasVisited) {
                // 确保Bootstrap已加载完成
                setTimeout(function() {
                    const welcomeModalEl = document.getElementById('welcomeModal');
                    const welcomeModal = new bootstrap.Modal(welcomeModalEl);
                    welcomeModal.show();
                    
                    // 设置访问标记，下次不再显示
                    localStorage.setItem('hasVisitedGridApp', 'true');
                }, 500);
            }
            
            // 添加测试按钮事件（开发期间使用，发布时可以移除）
            // document.getElementById('testModalBtn').addEventListener('click', function() {
            //     const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
            //     welcomeModal.show();
            // });
        }
        
        // 初始化帮助抽屉
        function initHelpDrawer() {
            const helpDrawer = document.getElementById('helpDrawer');
            const openHelpBtn = document.getElementById('openHelpBtn');
            const closeHelpBtn = document.getElementById('closeHelpBtn');
            
            // 打开帮助抽屉
            openHelpBtn.addEventListener('click', function() {
                helpDrawer.classList.add('open');
            });
            
            // 关闭帮助抽屉
            closeHelpBtn.addEventListener('click', function() {
                helpDrawer.classList.remove('open');
            });
            
            // 点击抽屉外部也可关闭抽屉
            document.addEventListener('click', function(event) {
                if (!helpDrawer.contains(event.target) && event.target !== openHelpBtn && helpDrawer.classList.contains('open')) {
                    helpDrawer.classList.remove('open');
                }
            });
        }
        
        // 初始化网格功能 - 原有的主要功能代码
        function initializeGrid() {
            const grid = document.getElementById('grid');
            const canvas = document.getElementById('linesCanvas');
            const statusEl = document.getElementById('status');
            const pointStatsEl = document.getElementById('pointStats');
            const timerInputEl = document.getElementById('timerInput');
            const timerDisplayEl = document.getElementById('timerDisplay');
            const dots = [];
            const dotPositions = [];
            const cellSize = 52; // 50px 格子大小 + 2px 间隔
            const maxVisibleDots = 25; // 最多显示25个点
            
            // 保存连线信息
            const lines = [];
            
            // 选择点的状态
            let firstSelectedDot = null;
            let firstSelectedIndex = -1;
            
            // 计时器变量
            let timerInterval = null;
            let timerSeconds = 0;
            let timerRunning = false;
            
            // 设置画布尺寸
            function resizeCanvas() {
                const gridRect = grid.getBoundingClientRect();
                canvas.width = gridRect.width;
                canvas.height = gridRect.height;
            }
            
            window.addEventListener('resize', function() {
                resizeCanvas();
                drawAllLines();
            });
            
            // 添加新连线
            function addLine(index1, index2) {
                // 检查是否已经存在这条线
                const lineExists = lines.some(line => 
                    (line.index1 === index1 && line.index2 === index2) || 
                    (line.index1 === index2 && line.index2 === index1)
                );
                
                if (!lineExists) {
                    // 获取点的位置
                    const rect1 = dots[index1].getBoundingClientRect();
                    const rect2 = dots[index2].getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // 计算点相对于canvas的位置
                    const x1 = rect1.left + rect1.width/2 - canvasRect.left;
                    const y1 = rect1.top + rect1.height/2 - canvasRect.top;
                    const x2 = rect2.left + rect2.width/2 - canvasRect.left;
                    const y2 = rect2.top + rect2.height/2 - canvasRect.top;
                    
                    lines.push({
                        index1: index1,
                        index2: index2,
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2,
                        id: Date.now() + Math.random().toString(36).substr(2, 9) // 生成唯一ID用于标识连线
                    });
                    
                    // 立即绘制所有线条
                    drawAllLines();
                }
            }
            
            // 移除指定连线
            function removeLine(lineId) {
                const lineIndex = lines.findIndex(line => line.id === lineId);
                if (lineIndex !== -1) {
                    // 保存被删除线的端点
                    const removedLine = lines[lineIndex];
                    // 删除线
                    lines.splice(lineIndex, 1);
                    // 重新绘制所有线
                    drawAllLines();
                    
                    // 重新计算点的连接状态（除了起点，其他点如果没有连线了，就恢复绿色）
                    updateDotsStatus();
                    
                    return removedLine;
                }
                return null;
            }
            
            // 更新所有点的状态（将不再连接的点恢复为绿色，保持起点为红色）
            function updateDotsStatus() {
                // 先清除所有点的选中状态（恢复为蓝色/绿色）
                dots.forEach(dot => {
                    dot.classList.remove('selected');
                    dot.classList.remove('manual-start'); // 清除手动模式起点标记
                });
                
                // 如果有起点，根据模式设置颜色
                if (firstSelectedDot) {
                    const connectionMode = document.querySelector('input[name="connectionMode"]:checked').value;
                    if (connectionMode === 'manual') {
                        firstSelectedDot.classList.add('manual-start'); // 紫色
                    } else {
                        firstSelectedDot.classList.add('selected'); // 红色
                    }
                }
                
                // 将所有存在于连线中的点标记为红色
                lines.forEach(line => {
                    dots[line.index1].classList.add('selected');
                    dots[line.index2].classList.add('selected');
                });
                
                // 确保起点的颜色优先级更高
                if (firstSelectedDot && firstSelectedIndex !== -1) {
                    const connectionMode = document.querySelector('input[name="connectionMode"]:checked').value;
                    if (connectionMode === 'manual') {
                        dots[firstSelectedIndex].classList.add('manual-start'); // 紫色
                        dots[firstSelectedIndex].classList.remove('selected'); // 移除红色
                    }
                }
            }
            
            // 清除所有连线
            function clearAllLines() {
                lines.length = 0;
                drawAllLines();
                // 清除选择状态
                clearSelectedDot();
                // 移除所有点的选中状态
                dots.forEach(dot => {
                    dot.classList.remove('selected');
                });
                statusEl.textContent = "已清除所有连线";
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            }
            
            // 绘制所有连线
            function drawAllLines() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 遍历所有线条
                for (const line of lines) {
                    // 如果任一点隐藏，则不绘制
                    if (dots[line.index1].classList.contains('hidden') || 
                        dots[line.index2].classList.contains('hidden')) {
                        continue;
                    }
                    
                    // 获取点的实际像素位置
                    const rect1 = dots[line.index1].getBoundingClientRect();
                    const rect2 = dots[line.index2].getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // 更新线条位置坐标，这对于鼠标悬停检测很重要
                    line.x1 = rect1.left + rect1.width/2 - canvasRect.left;
                    line.y1 = rect1.top + rect1.height/2 - canvasRect.top;
                    line.x2 = rect2.left + rect2.width/2 - canvasRect.left;
                    line.y2 = rect2.top + rect2.height/2 - canvasRect.top;
                    
                    // 绘制线条
                    ctx.beginPath();
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#2ecc71';
                    ctx.stroke();
                }
            }
            
            // 检查点是否靠近线段
            function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
                // 计算线段长度的平方
                const lineLength2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                if (lineLength2 === 0) return false; // 点不成线段
                
                // 计算点到线段的距离
                const t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength2));
                const projX = x1 + t * (x2 - x1);
                const projY = y1 + t * (y2 - y1);
                
                const distance = Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
                return distance <= tolerance;
            }
            
            // 添加鼠标移动事件，实现连线高亮和点击删除功能
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // 检查鼠标是否接近任何线条
                let hoveredLine = null;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // 跳过隐藏点的线条
                    if (dots[line.index1].classList.contains('hidden') || 
                        dots[line.index2].classList.contains('hidden')) {
                        continue;
                    }
                    
                    // 从点获取最新坐标
                    const rect1 = dots[line.index1].getBoundingClientRect();
                    const rect2 = dots[line.index2].getBoundingClientRect();
                    
                    // 计算在canvas中的相对坐标
                    const x1 = rect1.left + rect1.width/2 - rect.left;
                    const y1 = rect1.top + rect1.height/2 - rect.top;
                    const x2 = rect2.left + rect2.width/2 - rect.left;
                    const y2 = rect2.top + rect2.height/2 - rect.top;
                    
                    // 更新线条坐标
                    line.x1 = x1;
                    line.y1 = y1;
                    line.x2 = x2;
                    line.y2 = y2;
                    
                    // 计算鼠标到线段的距离
                    const distance = distanceToLine(mouseX, mouseY, x1, y1, x2, y2);
                    if (distance < 15) { // 增大检测范围
                        hoveredLine = line;
                        hoveredLine.index = i; // 保存索引，便于删除
                        break;
                    }
                }
                
                // 如果鼠标靠近线条，显示高亮，并设置cursor
                if (hoveredLine) {
                    canvas.style.cursor = 'pointer';
                    canvas.dataset.hoveredLineIndex = hoveredLine.index;
                    
                    // 重新绘制所有线条
                    drawAllLines();
                    
                    // 高亮显示该线条
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(hoveredLine.x1, hoveredLine.y1);
                    ctx.lineTo(hoveredLine.x2, hoveredLine.y2);
                    ctx.strokeStyle = '#e74c3c'; // 高亮颜色 - 红色
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    // 显示调试信息
                    statusEl.textContent = `悬停在连线上 [${hoveredLine.index1} - ${hoveredLine.index2}] (点击可删除)`;
                } else {
                    canvas.style.cursor = 'default';
                    canvas.dataset.hoveredLineIndex = '';
                    drawAllLines();
                }
            });
            
            // 简化距离计算函数
            function distanceToLine(px, py, x1, y1, x2, y2) {
                // 线段长度的平方
                const lineLength2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                if (lineLength2 === 0) return Number.MAX_VALUE; // 防止除零错误
                
                // 计算投影长度比例
                const t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength2;
                
                // 约束t在[0,1]范围内，确保投影点在线段上
                const tClamped = Math.max(0, Math.min(1, t));
                
                // 计算投影点坐标
                const projX = x1 + tClamped * (x2 - x1);
                const projY = y1 + tClamped * (y2 - y1);
                
                // 计算点到投影点的距离
                return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
            }
            
            // 添加点击事件，实现删除线条功能
            canvas.addEventListener('click', function(e) {
                const hoveredLineIndex = canvas.dataset.hoveredLineIndex;
                if (hoveredLineIndex !== '' && hoveredLineIndex !== undefined) {
                    // 删除该线条
                    const index = parseInt(hoveredLineIndex);
                    
                    if (index >= 0 && index < lines.length) {
                        console.log("删除连线:", lines[index]);
                        statusEl.textContent = `已删除连线 [${lines[index].index1} - ${lines[index].index2}]`;
                        
                        // 直接使用数组的splice方法删除
                        lines.splice(index, 1);
                        
                        // 重新绘制所有线段
                        drawAllLines();
                        
                        // 更新点的状态
                        updateDotsStatus();
                    }
                }
            });
            
            // 检查两点间距离是否为√5
            function isDistanceSqrt5(pos1, pos2) {
                const dx = Math.abs(pos1.x - pos2.x);
                const dy = Math.abs(pos1.y - pos2.y);
                return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
            }
            
            // 清除已选择的点
            function clearSelectedDot() {
                if (firstSelectedDot) {
                    firstSelectedDot.classList.remove('selected');
                    firstSelectedDot.classList.remove('manual-start'); // 清除手动模式起点标记
                    firstSelectedDot = null;
                    firstSelectedIndex = -1;
                }
                
                // 清除所有被选中的点
                dots.forEach(dot => {
                    dot.classList.remove('selected');
                    dot.classList.remove('manual-start'); // 清除手动模式起点标记
                });
                
                // 停止计时器
                stopTimer();
            }
            
            // 随机选择一个可见的点
            function randomSelectDot() {
                // 先清除之前选择的点
                clearSelectedDot();
                
                // 获取所有可见的点
                const visibleDots = dots.filter((dot, index) => !dot.classList.contains('hidden'));
                
                // 如果没有可见的点，提示用户
                if (visibleDots.length === 0) {
                    statusEl.textContent = "没有可见的点可供选择";
                    return;
                }
                
                // 随机选择一个可见的点
                const randomIndex = Math.floor(Math.random() * visibleDots.length);
                const selectedDot = visibleDots[randomIndex];
                const dotIndex = dots.indexOf(selectedDot);
                
                // 设置选中状态
                selectedDot.classList.add('selected');
                firstSelectedDot = selectedDot;
                firstSelectedIndex = dotIndex;
                
                statusEl.textContent = "已随机选择一个点，请选择第二个点完成连线";
                
                // 开始计时器
                startTimer();
            }
            
            // 获取所有已连线或被选中的点
            function getConnectedOrSelectedDots() {
                const connectedIndices = new Set();
                
                // 添加所有已连线的点
                lines.forEach(line => {
                    connectedIndices.add(line.index1);
                    connectedIndices.add(line.index2);
                });
                
                // 添加当前选中的点
                if (firstSelectedIndex !== -1) {
                    connectedIndices.add(firstSelectedIndex);
                }
                
                return Array.from(connectedIndices);
            }
            
            // 开始计时器
            function startTimer() {
                // 如果计时器已经在运行，不重新开始
                if (timerRunning) {
                    return;
                }
                
                // 停止之前的计时器
                stopTimer();
                
                // 获取用户设置的时间
                const seconds = parseInt(timerInputEl.value);
                if (isNaN(seconds) || seconds <= 0) {
                    timerInputEl.value = 10; // 默认10秒
                    timerSeconds = 10;
                } else {
                    timerSeconds = seconds;
                }
                
                // 更新显示
                updateTimerDisplay();
                
                // 开始新的计时器
                timerRunning = true;
                timerInterval = setInterval(function() {
                    timerSeconds--;
                    updateTimerDisplay();
                    
                    if (timerSeconds <= 0) {
                        // 计时结束
                        stopTimer();
                        
                        // 获取已连线或被选中的点
                        const connectedOrSelectedIndices = getConnectedOrSelectedDots();
                        
                        // 隐藏除了红色点以外的所有点
                        dots.forEach((dot, index) => {
                            if (!connectedOrSelectedIndices.includes(index) && !dot.classList.contains('selected')) {
                                dot.classList.add('hidden');
                            }
                            
                            // 确保所有连线的点都是红色的
                            if (connectedOrSelectedIndices.includes(index)) {
                                dot.classList.add('selected');
                            }
                        });
                        
                        drawAllLines();
                        updatePointStats();
                        statusEl.textContent = "时间到！已隐藏所有非连线点";
                    }
                }, 1000);
            }
            
            // 停止计时器
            function stopTimer() {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                timerRunning = false;
            }
            
            // 更新计时器显示
            function updateTimerDisplay() {
                const minutes = Math.floor(timerSeconds / 60);
                const seconds = timerSeconds % 60;
                timerDisplayEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // 随机选择网格中的位置放置点
            function getRandomPositions(total, max) {
                const positions = [];
                while (positions.length < total) {
                    const x = Math.floor(Math.random() * 10);
                    const y = Math.floor(Math.random() * 10);
                    const position = y * 10 + x;
                    
                    // 确保不重复
                    if (!positions.includes(position)) {
                        positions.push(position);
                    }
                }
                return positions;
            }
            
            // 获取25个随机位置
            const dotPositionsIndices = getRandomPositions(maxVisibleDots, 100);
            
            // 创建10×10的网格，但只在选定的25个位置放点
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    const position = i * 10 + j;
                    
                    // 创建所有格子的点，但根据位置决定是否隐藏
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    
                    // 如果不在选定的位置，默认隐藏
                    if (!dotPositionsIndices.includes(position)) {
                        dot.classList.add('hidden');
                    }
                    
                    const dotIndex = dots.length;
                    dots.push(dot);
                    
                    // 保存点的位置信息（网格坐标）
                    dotPositions.push({x: j, y: i});
                    
                    // 添加点击事件，处理点的选择和连线
                    dot.addEventListener('click', function(e) {
                        e.stopPropagation(); // 阻止冒泡到cell
                        
                        // 如果点是隐藏的，不做任何操作
                        if (dot.classList.contains('hidden')) {
                            return;
                        }
                        
                        // 获取连线模式
                        const connectionMode = document.querySelector('input[name="connectionMode"]:checked').value;
                        
                        // 获取已连线或被选中的点
                        const connectedOrSelected = getConnectedOrSelectedDots();
                        
                        // 手动模式处理
                        if (connectionMode === 'manual') {
                            // 如果点击的是红色或紫色点（已选中点）
                            if (dot.classList.contains('selected') || dot.classList.contains('manual-start') || connectedOrSelected.includes(dotIndex)) {
                                // 设置为起点
                                
                                // 清除之前所有起点标记，但保留红色连接点
                                if (firstSelectedDot) {
                                    firstSelectedDot.classList.remove('manual-start');
                                    // 如果之前的起点在连线中，则恢复为红色
                                    const isInLine = lines.some(line => 
                                        line.index1 === firstSelectedIndex || line.index2 === firstSelectedIndex
                                    );
                                    if (isInLine) {
                                        firstSelectedDot.classList.add('selected');
                                    }
                                }
                                
                                // 设置新的选中点
                                dot.classList.remove('selected'); // 先移除红色
                                dot.classList.add('manual-start'); // 添加紫色
                                firstSelectedDot = dot;
                                firstSelectedIndex = dotIndex;
                                
                                statusEl.textContent = "已选择起点，请选择第二个点完成连线";
                                
                                // 开始计时器
                                startTimer();
                                return;
                            }
                            
                            // 如果已有起点，且点击了非红色点
                            if (firstSelectedDot && !dot.classList.contains('selected')) {
                                // 检查是否可以连线（√5距离）
                                const pos1 = dotPositions[firstSelectedIndex];
                                const pos2 = dotPositions[dotIndex];
                                
                                if (isDistanceSqrt5(pos1, pos2)) {
                                    // 将当前点变成红色
                                    dot.classList.add('selected');
                                    
                                    // 添加连线
                                    addLine(firstSelectedIndex, dotIndex);
                                    drawAllLines();
                                    statusEl.textContent = "已连线！距离为√5";
                                    
                                    // 保持当前选中点不变，继续连线
                                } else {
                                    statusEl.textContent = "该点与起点的距离不是√5，不能连线";
                                }
                                return;
                            }
                            
                            // 如果没有起点且点击了非红色点
                            if (!firstSelectedDot && !dot.classList.contains('selected')) {
                                statusEl.textContent = "请先选择一个红色点作为起点";
                                return;
                            }
                        } 
                        // 自动模式处理
                        else {
                            // 如果点击的是红色点
                            if (dot.classList.contains('selected') || connectedOrSelected.includes(dotIndex)) {
                                statusEl.textContent = "在自动模式下，请使用'随机选择点'按钮来选择起点";
                                return;
                            }
                            
                            // 如果当前点不是红色的，检查是否可以与任何红色点连线
                            if (!dot.classList.contains('selected')) {
                                // 获取所有红色点
                                const selectedDots = [];
                                dots.forEach((d, idx) => {
                                    if (d.classList.contains('selected') && !d.classList.contains('hidden')) {
                                        selectedDots.push({ dot: d, index: idx });
                                    }
                                });
                                
                                // 如果没有选中任何点（即没有点过"随机选择点"按钮），显示提示信息
                                if (selectedDots.length === 0) {
                                    statusEl.textContent = "请先使用'随机选择点'按钮选择一个初始点";
                                    return;
                                }
                                
                                // 检查当前点是否可以与任何红色点连线
                                let canConnect = false;
                                let closestSelectedDotIndex = -1;
                                
                                for (const selected of selectedDots) {
                                    const pos1 = dotPositions[selected.index];
                                    const pos2 = dotPositions[dotIndex];
                                    
                                    if (isDistanceSqrt5(pos1, pos2)) {
                                        canConnect = true;
                                        closestSelectedDotIndex = selected.index;
                                        break;
                                    }
                                }
                                
                                if (canConnect) {
                                    // 将当前点变成红色
                                    dot.classList.add('selected');
                                    
                                    // 添加连线
                                    addLine(closestSelectedDotIndex, dotIndex);
                                    drawAllLines();
                                    statusEl.textContent = "已连线！距离为√5";
                                    
                                    // 设置当前点为选中点，方便继续连线
                                    firstSelectedDot = dot;
                                    firstSelectedIndex = dotIndex;
                                } else {
                                    statusEl.textContent = "该点与任何红色点的距离都不是√5，不能连线";
                                }
                                return;
                            }
                        }
                    });
                    
                    // 添加格子点击事件，切换点的显示/隐藏状态
                    cell.addEventListener('click', function() {
                        // 只有当不在选择点模式时才切换显示/隐藏
                        if (firstSelectedDot === null) {
                            // 如果点是隐藏的，检查是否可以显示（不超过25个点）
                            if (dot.classList.contains('hidden')) {
                                // 检查当前可见的点数
                                const visibleCount = updatePointStats();
                                if (visibleCount >= maxVisibleDots) {
                                    statusEl.textContent = `已达到最大点数限制(${maxVisibleDots}个)，请先隐藏一些点`;
                                    return;
                                }
                            }
                            
                            dot.classList.toggle('hidden');
                            drawAllLines();
                            updatePointStats();
                        }
                    });
                    
                    cell.appendChild(dot);
                    grid.appendChild(cell);
                }
            }
            
            // 统计当前可见的点数
            function updatePointStats() {
                const visibleCount = dots.filter(dot => !dot.classList.contains('hidden')).length;
                pointStatsEl.textContent = `可见点: ${visibleCount}/${dots.length}`;
                return visibleCount;
            }
            
            // 初始化画布
            setTimeout(resizeCanvas, 0);
            // 初始化点数统计
            setTimeout(updatePointStats, 0);
            // 初始化计时器显示
            updateTimerDisplay();
            
            // 控制按钮功能
            
            // 显示所有点
            document.getElementById('showAll').addEventListener('click', function() {
                dots.forEach(dot => {
                    dot.classList.remove('hidden');
                });
                // 清除所有连线
                clearAllLines();
                // 清除选择状态
                clearSelectedDot();
                updatePointStats();
                statusEl.textContent = "已显示所有点";
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            });
            
            // 隐藏所有点
            document.getElementById('hideAll').addEventListener('click', function() {
                dots.forEach(dot => {
                    dot.classList.add('hidden');
                });
                // 清除所有连线
                clearAllLines();
                // 清除选择状态
                clearSelectedDot();
                updatePointStats();
                statusEl.textContent = "已隐藏所有点";
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            });
            
            // 切换所有点的状态
            document.getElementById('toggleAll').addEventListener('click', function() {
                dots.forEach(dot => {
                    dot.classList.toggle('hidden');
                });
                // 清除所有连线
                clearAllLines();
                // 清除选择状态
                clearSelectedDot();
                updatePointStats();
                statusEl.textContent = "已切换所有点";
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            });
            
            // 随机显示/隐藏点
            document.getElementById('randomDots').addEventListener('click', function() {
                // 清除已选择的点
                clearSelectedDot();
                
                // 先隐藏所有点
                dots.forEach(dot => {
                    dot.classList.add('hidden');
                });
                
                // 获取25个随机索引
                const indices = [];
                while (indices.length < maxVisibleDots) {
                    const idx = Math.floor(Math.random() * dots.length);
                    if (!indices.includes(idx)) {
                        indices.push(idx);
                    }
                }
                
                // 显示随机选中的点
                indices.forEach(idx => {
                    dots[idx].classList.remove('hidden');
                });
                
                // 清除所有连线
                clearAllLines();
                
                drawAllLines();
                updatePointStats();
                statusEl.textContent = `已随机显示${maxVisibleDots}个点`;
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            });
            
            // 清除所有连线
            document.getElementById('clearLines').addEventListener('click', function() {
                clearAllLines();
                // 清除选择状态
                clearSelectedDot();
                // 移除所有点的选中状态
                dots.forEach(dot => {
                    dot.classList.remove('selected');
                });
                statusEl.textContent = "已清除所有连线";
                
                // 只重置计时器，不开始计时
                stopTimer();
                updateTimerDisplay();
            });
            
            // 随机选择一个点
            document.getElementById('randomSelect').addEventListener('click', function() {
                randomSelectDot();
                updatePointStats();
                
                // randomSelectDot函数中已经包含开始计时的逻辑
            });
            
            // 重置计时器
            document.getElementById('resetTimer').addEventListener('click', function() {
                // 重置计时器
                const seconds = parseInt(timerInputEl.value);
                if (isNaN(seconds) || seconds <= 0) {
                    timerInputEl.value = 1; // 默认1秒
                    timerSeconds = 1;
                } else {
                    timerSeconds = seconds;
                }
                
                // 只停止计时器，不开始新的计时
                stopTimer();
                updateTimerDisplay();
                
                statusEl.textContent = "已重置计时器";
            });
            
            // 监听计时器输入变化
            timerInputEl.addEventListener('change', function() {
                let value = parseInt(timerInputEl.value);
                if (isNaN(value) || value < 1) {
                    value = 1;
                } 
                timerInputEl.value = value;
                
                // 如果计时器正在运行，更新计时器
                if (timerRunning) {
                    timerSeconds = value;
                    updateTimerDisplay();
                }
            });
            
            // 初始化点布局管理系统
            initLayoutManager();
            
            // 初始化布局管理器
            function initLayoutManager() {
                // 加载已保存的布局到下拉菜单
                loadSavedLayouts();
                
                // 绑定保存布局按钮
                document.getElementById('saveLayout').addEventListener('click', function() {
                    saveCurrentLayout();
                });
                
                // 绑定加载布局按钮
                document.getElementById('loadLayout').addEventListener('click', function() {
                    loadSelectedLayout();
                });
                
                // 绑定删除布局按钮
                document.getElementById('deleteLayout').addEventListener('click', function() {
                    deleteSelectedLayout();
                });
            }
            
            // 保存当前点位布局
            function saveCurrentLayout() {
                const layoutName = document.getElementById('layoutName').value.trim();
                if (!layoutName) {
                    alert("请输入布局名称");
                    return;
                }
                
                // 获取当前显示的点位
                const visibleDots = [];
                dots.forEach((dot, index) => {
                    if (!dot.classList.contains('hidden')) {
                        visibleDots.push(index);
                    }
                });
                
                // 获取已有的布局
                let layouts = JSON.parse(localStorage.getItem('gridLayouts') || '{}');
                
                // 保存新布局
                layouts[layoutName] = {
                    name: layoutName,
                    dots: visibleDots,
                    timestamp: new Date().toISOString()
                };
                
                // 保存回localStorage
                localStorage.setItem('gridLayouts', JSON.stringify(layouts));
                
                // 更新下拉菜单
                loadSavedLayouts();
                
                // 选中刚保存的布局
                const select = document.getElementById('savedLayouts');
                select.value = layoutName;
                
                statusEl.textContent = `已保存点位布局: ${layoutName}`;
            }
            
            // 加载已保存的布局到下拉菜单
            function loadSavedLayouts() {
                const select = document.getElementById('savedLayouts');
                const layouts = JSON.parse(localStorage.getItem('gridLayouts') || '{}');
                
                // 清除现有选项（保留默认选项）
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // 添加保存的布局选项
                for (const name in layouts) {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                }
            }
            
            // 加载选中的布局
            function loadSelectedLayout() {
                const select = document.getElementById('savedLayouts');
                const layoutName = select.value;
                
                if (!layoutName) {
                    alert("请选择一个已保存的布局");
                    return;
                }
                
                const layouts = JSON.parse(localStorage.getItem('gridLayouts') || '{}');
                const layout = layouts[layoutName];
                
                if (!layout) {
                    alert("找不到选中的布局");
                    return;
                }
                
                // 先隐藏所有点
                dots.forEach(dot => dot.classList.add('hidden'));
                
                // 显示布局中的点
                layout.dots.forEach(index => {
                    if (index >= 0 && index < dots.length) {
                        dots[index].classList.remove('hidden');
                    }
                });
                
                // 清除所有连线
                clearAllLines();
                
                // 更新UI
                drawAllLines();
                updatePointStats();
                statusEl.textContent = `已加载点位布局: ${layoutName}`;
                
                // 停止计时器
                stopTimer();
                updateTimerDisplay();
            }
            
            // 删除选中的布局
            function deleteSelectedLayout() {
                const select = document.getElementById('savedLayouts');
                const layoutName = select.value;
                
                if (!layoutName) {
                    alert("请选择一个已保存的布局");
                    return;
                }
                
                // 获取已有的布局
                let layouts = JSON.parse(localStorage.getItem('gridLayouts') || '{}');
                
                // 删除选中的布局
                if (layouts[layoutName]) {
                    delete layouts[layoutName];
                    localStorage.setItem('gridLayouts', JSON.stringify(layouts));
                    
                    // 更新下拉菜单
                    loadSavedLayouts();
                    select.value = "";
                    
                    statusEl.textContent = `已删除点位布局: ${layoutName}`;
                } else {
                    alert("找不到选中的布局");
                }
            }
            
            // 监听连线模式切换
            document.querySelectorAll('input[name="connectionMode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    const mode = this.value;
                    
                    // 更新点的显示状态，但不改变连线状态
                    if (mode === 'manual') {
                        // 如果有起点，将其变为紫色
                        if (firstSelectedDot) {
                            firstSelectedDot.classList.remove('selected');
                            firstSelectedDot.classList.add('manual-start');
                        }
                        statusEl.textContent = "已切换到手动选择模式，点击红色点设为起点";
                    } else {
                        // 如果有起点，将其变为红色
                        if (firstSelectedDot) {
                            firstSelectedDot.classList.remove('manual-start');
                            firstSelectedDot.classList.add('selected');
                        }
                        statusEl.textContent = "已切换到自动连接模式，使用随机选择点按钮选择起点";
                    }
                    
                    // 重新绘制所有线条
                    drawAllLines();
                    
                    // 重新更新点的状态
                    updateDotsStatus();
                    
                    // 不重置计时器，保留当前计时状态
                });
            });
        } // 闭合initializeGrid函数
    </script>
</body>
</html>
